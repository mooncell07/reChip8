{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Lemon.pie  <p>Lemon, or Lemon.pie (as I like to call it \ud83d\ude42), is yet another hobby emulator for the classic variant of the CHIP-8 Virtual Machine written in Python. It's just a toy emulator with no exclusive features that I made solely for my own learning experience. Although I think it's fine for some casual gameplay, I don't really recommend using it for any sort of serious tasks, especially if the task relies on timing accuracy because the timing is really broken!</p>"},{"location":"#test-results","title":"Test Results:","text":"<p>tested with chip8-test-suite's ver. 4.1</p> <ul> <li> <p>Chip8 Test Suite's logo: </p> </li> <li> <p>IBM Logo: </p> </li> <li> <p>Corax Test: </p> </li> <li> <p>Flags Test: </p> </li> <li> <p>Quirks Test: </p> </li> <li> <p>Keypad Halt Test: </p> </li> <li> <p>Beep Test:</p> </li> </ul>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>Thanks to...</p> <ul> <li>Cowgod's Chip-8 Technical Reference.</li> <li>Tobias V. Langhoff for the incredible guide.</li> <li>Timendus for the amazing test suite.</li> <li>The r/emu community.</li> </ul>"},{"location":"Lemon.pie/cpu/","title":"CPU","text":"<p>CPU of the Emulator.</p> Source code in <code>components/cpu.py</code> <pre><code>class CPU:\n    \"\"\"\n    CPU of the Emulator.\n    \"\"\"\n\n    __slots__ = (\n        \"DT\",\n        \"I\",\n        \"PC\",\n        \"ST\",\n        \"V\",\n        \"display\",\n        \"halt\",\n        \"keypad\",\n        \"memory\",\n        \"op\",\n        \"sound\",\n        \"stack\",\n        \"sync\",\n    )\n\n    def __init__(self, display: Display, memory: Memory, keypad: Keypad) -&gt; None:\n        \"\"\"\n        CPU construtor.\n\n        Args:\n            memory: Primary Memory of size 4096 bytes.\n            display: Display Handler for rendering sprites.\n            keypad: 16-key hexadecimal keypad for taking input.\n\n        Attributes:\n            sound (pygame.mixer.Sound): A [pygame.mixer.Sound](https://www.pygame.org/docs/ref/mixer.html#pygame.mixer.Sound) object.\n            op (Opcode): Opcode for identifying operation.\n\n            V (List[int]): 16 General Purpose 8-bit registers.\n            I (int): 16-bit Index register to store memory locations.\n            DT (int): 8-bit Delay Timer.\n            ST (int): 8-bit Sound Timer.\n            PC (int): 16-bit register to store the currently executing address.\n            stack (List[int]): Array of 16 16-bit values for nesting subroutines.\n\n            halt (bool): Flag to check if the CPU is halted.\n            sync (bool): Flag to sync the display with the timer.\n        \"\"\"\n        # devices\n        self.display = display\n        self.memory = memory\n        self.keypad = keypad\n        self.sound: pygame.mixer.Sound = pygame.mixer.Sound(\"beep.mp3\")\n        self.op: Opcode = Opcode(inst=0x0000)\n\n        # registers\n        self.V: t.List[int] = [0] * 16\n        self.I: int = 0\n        self.DT: int = 0\n        self.ST: int = 0\n        self.PC: int = INIT_LOC_CONSTANT\n        self.stack: t.List[int] = [0] * 16\n\n        # flags\n        self.halt: bool = False\n        self.sync: bool = False\n\n    def SYS_addr(self) -&gt; None:\n        \"\"\"\n        $0nnn - Jump to a machine code routine at nnn. (Edit: use kk instead)\n        \"\"\"\n        optab = {0xE0: self.CLS, 0xEE: self.RET}\n        optab[self.op.kk]()\n\n    def CLS(self) -&gt; None:\n        \"\"\"\n        $00E0 - Clear the display.\n        \"\"\"\n        self.display.clear()\n\n    def RET(self) -&gt; None:\n        \"\"\"\n        $00EE - Return from a subroutine.\n        \"\"\"\n        self.PC = self.stack.pop()\n\n    def JP_addr(self) -&gt; None:\n        \"\"\"\n        $1nnn - Jump to location nnn. (PC = nnn)\n        \"\"\"\n        self.PC = self.op.nnn\n\n    def CALL_addr(self) -&gt; None:\n        \"\"\"\n        $2nnn - Call subroutine at nnn.\n        \"\"\"\n        self.stack.append(self.PC)\n        self.PC = self.op.nnn\n\n    def SE_Vx_byte(self) -&gt; None:\n        \"\"\"\n        $3xkk - Skip next instruction if Vx = kk.\n        \"\"\"\n        if self.V[self.op.x] == self.op.kk:\n            self.PC += 2\n\n    def SNE_Vx_byte(self) -&gt; None:\n        \"\"\"\n        $4xkk - Skip next instruction if Vx != kk.\n        \"\"\"\n        if self.V[self.op.x] != self.op.kk:\n            self.PC += 2\n\n    def SE_Vx_Vy(self) -&gt; None:\n        \"\"\"\n        $5xy0 - Skip next instruction if Vx = Vy.\n        \"\"\"\n        if self.V[self.op.x] == self.V[self.op.y]:\n            self.PC += 2\n\n    def LD_Vx_byte(self) -&gt; None:\n        \"\"\"\n        $6xkk - Set Vx = kk.\n        \"\"\"\n        self.V[self.op.x] = self.op.kk\n\n    def ADD_Vx_byte(self) -&gt; None:\n        \"\"\"\n        $7xkk - Set Vx = Vx + kk.\n        \"\"\"\n        self.V[self.op.x] = (self.V[self.op.x] + self.op.kk) &amp; 0xFF\n\n    def JP_addr_8(self) -&gt; None:\n        \"\"\"\n        $8xyn -  Jump to a machine code routine at n.\n        \"\"\"\n        optab = {\n            0x0: self.LD_Vx_Vy,\n            0x1: self.OR_Vx_Vy,\n            0x2: self.AND_Vx_Vy,\n            0x3: self.XOR_Vx_Vy,\n            0x4: self.ADD_Vx_Vy,\n            0x5: self.SUB_Vx_Vy,\n            0x6: self.SHR_Vx_Vy,\n            0x7: self.SUBN_Vx_Vy,\n            0xE: self.SHL_Vx_Vy,\n        }\n        optab[self.op.n]()\n\n    def LD_Vx_Vy(self) -&gt; None:\n        \"\"\"\n        $8xy0 - Set Vx = Vy.\n        \"\"\"\n        self.V[self.op.x] = (self.V[self.op.y]) &amp; 0xFF\n\n    def OR_Vx_Vy(self) -&gt; None:\n        \"\"\"\n        $8xy1 - Set Vx = Vx OR Vy.\n        \"\"\"\n        self.V[self.op.x] = (self.V[self.op.x] | self.V[self.op.y]) &amp; 0xFF\n        self.V[0xF] = 0\n\n    def AND_Vx_Vy(self) -&gt; None:\n        \"\"\"\n        $8xy2 - Set Vx = Vx AND Vy.\n        \"\"\"\n        self.V[self.op.x] = (self.V[self.op.x] &amp; self.V[self.op.y]) &amp; 0xFF\n        self.V[0xF] = 0\n\n    def XOR_Vx_Vy(self) -&gt; None:\n        \"\"\"\n        $8xy3 - Set Vx = Vx XOR Vy.\n        \"\"\"\n        self.V[self.op.x] = (self.V[self.op.x] ^ self.V[self.op.y]) &amp; 0xFF\n        self.V[0xF] = 0\n\n    def ADD_Vx_Vy(self) -&gt; None:\n        \"\"\"\n        $8xy4 - Set Vx = Vx + Vy, set VF = carry.\n        \"\"\"\n        val = self.V[self.op.x] + self.V[self.op.y]\n        self.V[self.op.x] = val &amp; 0xFF\n\n        if val &gt; 0xFF:\n            self.V[0xF] = 1\n        else:\n            self.V[0xF] = 0\n\n    def SUB_Vx_Vy(self) -&gt; None:\n        \"\"\"\n        $8xy5 - Set Vx = Vx - Vy, set VF = NOT borrow.\n        \"\"\"\n        x = self.V[self.op.x]\n        y = self.V[self.op.y]\n\n        self.V[self.op.x] = (x - y) &amp; 0xFF\n\n        if x &lt; y:\n            self.V[0xF] = 0\n        else:\n            self.V[0xF] = 1\n\n    def SHR_Vx_Vy(self) -&gt; None:\n        \"\"\"\n        $8xy6 - Set Vx = Vx SHR 1.\n        \"\"\"\n        prev = self.V[self.op.x]\n        self.V[self.op.x] = self.V[self.op.y]\n        self.V[self.op.x] = (self.V[self.op.x] &gt;&gt; 1) &amp; 0xFF\n        self.V[0xF] = prev &amp; 1\n\n    def SUBN_Vx_Vy(self) -&gt; None:\n        \"\"\"\n        $8xy7 - Set Vx = Vy - Vx, set VF = NOT borrow.\n        \"\"\"\n        self.V[self.op.x] = (self.V[self.op.y] - self.V[self.op.x]) &amp; 0xFF\n        if self.V[self.op.x] &gt; self.V[self.op.y]:\n            self.V[0xF] = 0\n        else:\n            self.V[0xF] = 1\n\n    def SHL_Vx_Vy(self) -&gt; None:\n        \"\"\"\n        $8xyE - Set Vx = Vx SHL 1.\n        \"\"\"\n        y = self.V[self.op.y]\n\n        self.V[self.op.x] = (y &lt;&lt; 1) &amp; 0xFF\n        self.V[0xF] = (y &amp; 0xFF) &gt;&gt; 7\n\n    def SNE_Vx_Vy(self) -&gt; None:\n        \"\"\"\n        $9xy0 - Skip next instruction if Vx != Vy.\n        \"\"\"\n        if self.V[self.op.x] != self.V[self.op.y]:\n            self.PC += 2\n\n    def LD_I_addr(self) -&gt; None:\n        \"\"\"\n        $Annn - Set I = nnn.\n        \"\"\"\n        self.I = self.op.nnn\n\n    def JP_V0_addr(self) -&gt; None:\n        \"\"\"\n        $Bnnn - Jump to location nnn + V0.\n        \"\"\"\n        self.PC = self.op.nnn + self.V[0]\n\n    def RND_Vx_byte(self) -&gt; None:\n        \"\"\"\n        $Cxkk - Set Vx = random byte AND kk.\n        \"\"\"\n        self.V[self.op.x] = randint(0, 0xFF) &amp; self.op.kk\n\n    def DRW_Vx_Vy_nibble(self) -&gt; None:\n        \"\"\"\n        $Dxyn - Display n-byte sprite starting at memory location I at (Vx, Vy), set VF = collision. :)\n        \"\"\"\n        if not self.sync:\n            self.PC -= 2\n            return\n\n        x = self.V[self.op.x] % COLUMNS\n        y = self.V[self.op.y] % ROWS\n\n        self.V[0xF] = 0\n\n        for i in range(self.op.n):\n            sprite = self.memory.space[self.I + i]\n            if (y + i) &lt;= ROWS:\n                for j in range(8):\n                    if (x + j) &lt;= COLUMNS:\n                        px = (sprite &gt;&gt; (7 - j)) &amp; 1\n                        index = self.display.wrap(x + j, y + i)\n\n                        if px == 1 and self.display.buffer[index] == 1:\n                            self.V[0xF] = 1\n\n                        self.display.buffer[index] ^= px\n\n        self.sync = False\n\n    def Jp_addr_E(self) -&gt; None:\n        \"\"\"\n        $Exkk - Jump to a machine code routine at kk.\n        \"\"\"\n        optab = {0x9E: self.SKP_Vx, 0xA1: self.SKNP_Vx}\n        optab[self.op.kk]()\n\n    def SKP_Vx(self) -&gt; None:\n        \"\"\"\n        $Ex9E - Skip next instruction if key with the value of Vx is pressed.\n        \"\"\"\n        if self.keypad.state[self.V[self.op.x] &amp; 0xF]:\n            self.PC += 2\n\n    def SKNP_Vx(self) -&gt; None:\n        \"\"\"\n        $ExA1 - Skip next instruction if key with the value of Vx is not pressed.\n        \"\"\"\n        if not self.keypad.state[self.V[self.op.x] &amp; 0xF]:\n            self.PC += 2\n\n    def Jp_addr_F(self) -&gt; None:\n        \"\"\"\n        $Fxkk - Jump to a machine code routine at kk.\n        \"\"\"\n        optab = {\n            0x07: self.LD_Vx_DT,\n            0x0A: self.LD_Vx_K,\n            0x15: self.LD_DT_Vx,\n            0x18: self.LD_ST_Vx,\n            0x1E: self.ADD_I_Vx,\n            0x29: self.LD_F_Vx,\n            0x33: self.LD_B_Vx,\n            0x55: self.LD_I_Vx,\n            0x65: self.LD_Vx_I,\n        }\n        optab[self.op.kk]()\n\n    def LD_Vx_DT(self) -&gt; None:\n        \"\"\"\n        $Fx07 - Set Vx = delay timer value.\n        \"\"\"\n        self.V[self.op.x] = self.DT\n\n    def LD_Vx_K(self) -&gt; None:\n        \"\"\"\n        $Fx0A - Wait for a key press, store the value of the key in Vx.\n        \"\"\"\n        self.halt = True\n\n    def LD_DT_Vx(self) -&gt; None:\n        \"\"\"\n        $Fx15 - Set delay timer = Vx.\n        \"\"\"\n        self.DT = self.V[self.op.x]\n\n    def LD_ST_Vx(self) -&gt; None:\n        \"\"\"\n        $Fx18 - Set sound timer = Vx.\n        \"\"\"\n        self.ST = self.V[self.op.x]\n\n    def ADD_I_Vx(self) -&gt; None:\n        \"\"\"\n        $Fx1E - Set I = I + Vx.\n        \"\"\"\n        self.I += self.V[self.op.x]\n\n    def LD_F_Vx(self) -&gt; None:\n        \"\"\"\n        $Fx29 - Set I = location of sprite for digit Vx.\n        \"\"\"\n        self.I = (self.V[self.op.x] * 5) &amp; 0x0FFF\n\n    def LD_B_Vx(self) -&gt; None:\n        \"\"\"\n        $Fx33 - Store BCD representation of Vx in memory locations I, I+1, and I+2.\n        \"\"\"\n        self.memory.space[self.I] = self.V[self.op.x] // 100\n        self.memory.space[self.I + 1] = (self.V[self.op.x] % 100) // 10\n        self.memory.space[self.I + 2] = self.V[self.op.x] % 10\n\n    def LD_I_Vx(self) -&gt; None:\n        \"\"\"\n        $Fx55 - Store registers V0 through Vx in memory starting at location I.\n        \"\"\"\n        for i in range(self.op.x + 1):\n            self.memory.space[self.I + i] = self.V[i]\n        self.I += self.op.x + 1\n\n    def LD_Vx_I(self) -&gt; None:\n        \"\"\"\n        $Fx65 - Read registers V0 through Vx from memory starting at location I.\n        \"\"\"\n        for i in range(self.op.x + 1):\n            self.V[i] = self.memory.space[self.I + i]\n        self.I += self.op.x + 1\n\n    @property\n    def optable(self) -&gt; t.Mapping[int, t.Callable[..., None]]:\n        \"\"\"\n        Opcode function lookup table.\n\n        Returns:\n            dict: opcode.type:subroutine mapping.\n        \"\"\"\n        return {\n            0x0: self.SYS_addr,\n            0x1: self.JP_addr,\n            0x2: self.CALL_addr,\n            0x3: self.SE_Vx_byte,\n            0x4: self.SNE_Vx_byte,\n            0x5: self.SE_Vx_Vy,\n            0x6: self.LD_Vx_byte,\n            0x7: self.ADD_Vx_byte,\n            0x8: self.JP_addr_8,\n            0x9: self.SNE_Vx_Vy,\n            0xA: self.LD_I_addr,\n            0xB: self.JP_V0_addr,\n            0xC: self.RND_Vx_byte,\n            0xD: self.DRW_Vx_Vy_nibble,\n            0xE: self.Jp_addr_E,\n            0xF: self.Jp_addr_F,\n        }\n\n    def beep(self) -&gt; None:\n        \"\"\"\n        Make a beep sound.\n        \"\"\"\n        self.sound.play()\n\n    def cycle(self) -&gt; None:\n        \"\"\"\n        Fetch, Decode and Execute instructions from the memory.\n        \"\"\"\n        fetch = (self.memory.space[self.PC] &lt;&lt; 8) | self.memory.space[self.PC + 1]\n        self.op = Opcode(fetch)\n        self.PC += 2\n\n        try:\n            self.optable[(self.op.type &amp; 0xF000) &gt;&gt; 12]()\n        except KeyError:\n            logging.error(f\"{CROSS} Opcode not found: {hex(self.op.inst)}\")\n            self.display.destroy()\n\n    def handle_timers(self) -&gt; None:\n        \"\"\"\n        Decrement ST and DT.\n        \"\"\"\n        if self.DT &gt; 0:\n            self.DT -= 1\n\n        if self.ST &gt; 0:\n            self.ST = 0\n            self.beep()\n</code></pre>"},{"location":"Lemon.pie/cpu/#components.CPU.optable","title":"<code>optable: t.Mapping[int, t.Callable[..., None]]</code>  <code>property</code>","text":"<p>Opcode function lookup table.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>Mapping[int, Callable[..., None]]</code> <p>opcode.type:subroutine mapping.</p>"},{"location":"Lemon.pie/cpu/#components.CPU.__init__","title":"<code>__init__(display, memory, keypad)</code>","text":"<p>CPU construtor.</p> <p>Parameters:</p> Name Type Description Default <code>memory</code> <code>Memory</code> <p>Primary Memory of size 4096 bytes.</p> required <code>display</code> <code>Display</code> <p>Display Handler for rendering sprites.</p> required <code>keypad</code> <code>Keypad</code> <p>16-key hexadecimal keypad for taking input.</p> required <p>Attributes:</p> Name Type Description <code>sound</code> <code>Sound</code> <p>A pygame.mixer.Sound object.</p> <code>op</code> <code>Opcode</code> <p>Opcode for identifying operation.</p> <code>V</code> <code>List[int]</code> <p>16 General Purpose 8-bit registers.</p> <code>I</code> <code>int</code> <p>16-bit Index register to store memory locations.</p> <code>DT</code> <code>int</code> <p>8-bit Delay Timer.</p> <code>ST</code> <code>int</code> <p>8-bit Sound Timer.</p> <code>PC</code> <code>int</code> <p>16-bit register to store the currently executing address.</p> <code>stack</code> <code>List[int]</code> <p>Array of 16 16-bit values for nesting subroutines.</p> <code>halt</code> <code>bool</code> <p>Flag to check if the CPU is halted.</p> <code>sync</code> <code>bool</code> <p>Flag to sync the display with the timer.</p> Source code in <code>components/cpu.py</code> <pre><code>def __init__(self, display: Display, memory: Memory, keypad: Keypad) -&gt; None:\n    \"\"\"\n    CPU construtor.\n\n    Args:\n        memory: Primary Memory of size 4096 bytes.\n        display: Display Handler for rendering sprites.\n        keypad: 16-key hexadecimal keypad for taking input.\n\n    Attributes:\n        sound (pygame.mixer.Sound): A [pygame.mixer.Sound](https://www.pygame.org/docs/ref/mixer.html#pygame.mixer.Sound) object.\n        op (Opcode): Opcode for identifying operation.\n\n        V (List[int]): 16 General Purpose 8-bit registers.\n        I (int): 16-bit Index register to store memory locations.\n        DT (int): 8-bit Delay Timer.\n        ST (int): 8-bit Sound Timer.\n        PC (int): 16-bit register to store the currently executing address.\n        stack (List[int]): Array of 16 16-bit values for nesting subroutines.\n\n        halt (bool): Flag to check if the CPU is halted.\n        sync (bool): Flag to sync the display with the timer.\n    \"\"\"\n    # devices\n    self.display = display\n    self.memory = memory\n    self.keypad = keypad\n    self.sound: pygame.mixer.Sound = pygame.mixer.Sound(\"beep.mp3\")\n    self.op: Opcode = Opcode(inst=0x0000)\n\n    # registers\n    self.V: t.List[int] = [0] * 16\n    self.I: int = 0\n    self.DT: int = 0\n    self.ST: int = 0\n    self.PC: int = INIT_LOC_CONSTANT\n    self.stack: t.List[int] = [0] * 16\n\n    # flags\n    self.halt: bool = False\n    self.sync: bool = False\n</code></pre>"},{"location":"Lemon.pie/cpu/#components.CPU.SYS_addr","title":"<code>SYS_addr()</code>","text":"<p>$0nnn - Jump to a machine code routine at nnn. (Edit: use kk instead)</p> Source code in <code>components/cpu.py</code> <pre><code>def SYS_addr(self) -&gt; None:\n    \"\"\"\n    $0nnn - Jump to a machine code routine at nnn. (Edit: use kk instead)\n    \"\"\"\n    optab = {0xE0: self.CLS, 0xEE: self.RET}\n    optab[self.op.kk]()\n</code></pre>"},{"location":"Lemon.pie/cpu/#components.CPU.CLS","title":"<code>CLS()</code>","text":"<p>$00E0 - Clear the display.</p> Source code in <code>components/cpu.py</code> <pre><code>def CLS(self) -&gt; None:\n    \"\"\"\n    $00E0 - Clear the display.\n    \"\"\"\n    self.display.clear()\n</code></pre>"},{"location":"Lemon.pie/cpu/#components.CPU.RET","title":"<code>RET()</code>","text":"<p>$00EE - Return from a subroutine.</p> Source code in <code>components/cpu.py</code> <pre><code>def RET(self) -&gt; None:\n    \"\"\"\n    $00EE - Return from a subroutine.\n    \"\"\"\n    self.PC = self.stack.pop()\n</code></pre>"},{"location":"Lemon.pie/cpu/#components.CPU.JP_addr","title":"<code>JP_addr()</code>","text":"<p>$1nnn - Jump to location nnn. (PC = nnn)</p> Source code in <code>components/cpu.py</code> <pre><code>def JP_addr(self) -&gt; None:\n    \"\"\"\n    $1nnn - Jump to location nnn. (PC = nnn)\n    \"\"\"\n    self.PC = self.op.nnn\n</code></pre>"},{"location":"Lemon.pie/cpu/#components.CPU.CALL_addr","title":"<code>CALL_addr()</code>","text":"<p>$2nnn - Call subroutine at nnn.</p> Source code in <code>components/cpu.py</code> <pre><code>def CALL_addr(self) -&gt; None:\n    \"\"\"\n    $2nnn - Call subroutine at nnn.\n    \"\"\"\n    self.stack.append(self.PC)\n    self.PC = self.op.nnn\n</code></pre>"},{"location":"Lemon.pie/cpu/#components.CPU.SE_Vx_byte","title":"<code>SE_Vx_byte()</code>","text":"<p>$3xkk - Skip next instruction if Vx = kk.</p> Source code in <code>components/cpu.py</code> <pre><code>def SE_Vx_byte(self) -&gt; None:\n    \"\"\"\n    $3xkk - Skip next instruction if Vx = kk.\n    \"\"\"\n    if self.V[self.op.x] == self.op.kk:\n        self.PC += 2\n</code></pre>"},{"location":"Lemon.pie/cpu/#components.CPU.SNE_Vx_byte","title":"<code>SNE_Vx_byte()</code>","text":"<p>$4xkk - Skip next instruction if Vx != kk.</p> Source code in <code>components/cpu.py</code> <pre><code>def SNE_Vx_byte(self) -&gt; None:\n    \"\"\"\n    $4xkk - Skip next instruction if Vx != kk.\n    \"\"\"\n    if self.V[self.op.x] != self.op.kk:\n        self.PC += 2\n</code></pre>"},{"location":"Lemon.pie/cpu/#components.CPU.SE_Vx_Vy","title":"<code>SE_Vx_Vy()</code>","text":"<p>$5xy0 - Skip next instruction if Vx = Vy.</p> Source code in <code>components/cpu.py</code> <pre><code>def SE_Vx_Vy(self) -&gt; None:\n    \"\"\"\n    $5xy0 - Skip next instruction if Vx = Vy.\n    \"\"\"\n    if self.V[self.op.x] == self.V[self.op.y]:\n        self.PC += 2\n</code></pre>"},{"location":"Lemon.pie/cpu/#components.CPU.LD_Vx_byte","title":"<code>LD_Vx_byte()</code>","text":"<p>$6xkk - Set Vx = kk.</p> Source code in <code>components/cpu.py</code> <pre><code>def LD_Vx_byte(self) -&gt; None:\n    \"\"\"\n    $6xkk - Set Vx = kk.\n    \"\"\"\n    self.V[self.op.x] = self.op.kk\n</code></pre>"},{"location":"Lemon.pie/cpu/#components.CPU.ADD_Vx_byte","title":"<code>ADD_Vx_byte()</code>","text":"<p>$7xkk - Set Vx = Vx + kk.</p> Source code in <code>components/cpu.py</code> <pre><code>def ADD_Vx_byte(self) -&gt; None:\n    \"\"\"\n    $7xkk - Set Vx = Vx + kk.\n    \"\"\"\n    self.V[self.op.x] = (self.V[self.op.x] + self.op.kk) &amp; 0xFF\n</code></pre>"},{"location":"Lemon.pie/cpu/#components.CPU.JP_addr_8","title":"<code>JP_addr_8()</code>","text":"<p>$8xyn -  Jump to a machine code routine at n.</p> Source code in <code>components/cpu.py</code> <pre><code>def JP_addr_8(self) -&gt; None:\n    \"\"\"\n    $8xyn -  Jump to a machine code routine at n.\n    \"\"\"\n    optab = {\n        0x0: self.LD_Vx_Vy,\n        0x1: self.OR_Vx_Vy,\n        0x2: self.AND_Vx_Vy,\n        0x3: self.XOR_Vx_Vy,\n        0x4: self.ADD_Vx_Vy,\n        0x5: self.SUB_Vx_Vy,\n        0x6: self.SHR_Vx_Vy,\n        0x7: self.SUBN_Vx_Vy,\n        0xE: self.SHL_Vx_Vy,\n    }\n    optab[self.op.n]()\n</code></pre>"},{"location":"Lemon.pie/cpu/#components.CPU.LD_Vx_Vy","title":"<code>LD_Vx_Vy()</code>","text":"<p>$8xy0 - Set Vx = Vy.</p> Source code in <code>components/cpu.py</code> <pre><code>def LD_Vx_Vy(self) -&gt; None:\n    \"\"\"\n    $8xy0 - Set Vx = Vy.\n    \"\"\"\n    self.V[self.op.x] = (self.V[self.op.y]) &amp; 0xFF\n</code></pre>"},{"location":"Lemon.pie/cpu/#components.CPU.OR_Vx_Vy","title":"<code>OR_Vx_Vy()</code>","text":"<p>$8xy1 - Set Vx = Vx OR Vy.</p> Source code in <code>components/cpu.py</code> <pre><code>def OR_Vx_Vy(self) -&gt; None:\n    \"\"\"\n    $8xy1 - Set Vx = Vx OR Vy.\n    \"\"\"\n    self.V[self.op.x] = (self.V[self.op.x] | self.V[self.op.y]) &amp; 0xFF\n    self.V[0xF] = 0\n</code></pre>"},{"location":"Lemon.pie/cpu/#components.CPU.AND_Vx_Vy","title":"<code>AND_Vx_Vy()</code>","text":"<p>$8xy2 - Set Vx = Vx AND Vy.</p> Source code in <code>components/cpu.py</code> <pre><code>def AND_Vx_Vy(self) -&gt; None:\n    \"\"\"\n    $8xy2 - Set Vx = Vx AND Vy.\n    \"\"\"\n    self.V[self.op.x] = (self.V[self.op.x] &amp; self.V[self.op.y]) &amp; 0xFF\n    self.V[0xF] = 0\n</code></pre>"},{"location":"Lemon.pie/cpu/#components.CPU.XOR_Vx_Vy","title":"<code>XOR_Vx_Vy()</code>","text":"<p>$8xy3 - Set Vx = Vx XOR Vy.</p> Source code in <code>components/cpu.py</code> <pre><code>def XOR_Vx_Vy(self) -&gt; None:\n    \"\"\"\n    $8xy3 - Set Vx = Vx XOR Vy.\n    \"\"\"\n    self.V[self.op.x] = (self.V[self.op.x] ^ self.V[self.op.y]) &amp; 0xFF\n    self.V[0xF] = 0\n</code></pre>"},{"location":"Lemon.pie/cpu/#components.CPU.ADD_Vx_Vy","title":"<code>ADD_Vx_Vy()</code>","text":"<p>$8xy4 - Set Vx = Vx + Vy, set VF = carry.</p> Source code in <code>components/cpu.py</code> <pre><code>def ADD_Vx_Vy(self) -&gt; None:\n    \"\"\"\n    $8xy4 - Set Vx = Vx + Vy, set VF = carry.\n    \"\"\"\n    val = self.V[self.op.x] + self.V[self.op.y]\n    self.V[self.op.x] = val &amp; 0xFF\n\n    if val &gt; 0xFF:\n        self.V[0xF] = 1\n    else:\n        self.V[0xF] = 0\n</code></pre>"},{"location":"Lemon.pie/cpu/#components.CPU.SUB_Vx_Vy","title":"<code>SUB_Vx_Vy()</code>","text":"<p>$8xy5 - Set Vx = Vx - Vy, set VF = NOT borrow.</p> Source code in <code>components/cpu.py</code> <pre><code>def SUB_Vx_Vy(self) -&gt; None:\n    \"\"\"\n    $8xy5 - Set Vx = Vx - Vy, set VF = NOT borrow.\n    \"\"\"\n    x = self.V[self.op.x]\n    y = self.V[self.op.y]\n\n    self.V[self.op.x] = (x - y) &amp; 0xFF\n\n    if x &lt; y:\n        self.V[0xF] = 0\n    else:\n        self.V[0xF] = 1\n</code></pre>"},{"location":"Lemon.pie/cpu/#components.CPU.SHR_Vx_Vy","title":"<code>SHR_Vx_Vy()</code>","text":"<p>$8xy6 - Set Vx = Vx SHR 1.</p> Source code in <code>components/cpu.py</code> <pre><code>def SHR_Vx_Vy(self) -&gt; None:\n    \"\"\"\n    $8xy6 - Set Vx = Vx SHR 1.\n    \"\"\"\n    prev = self.V[self.op.x]\n    self.V[self.op.x] = self.V[self.op.y]\n    self.V[self.op.x] = (self.V[self.op.x] &gt;&gt; 1) &amp; 0xFF\n    self.V[0xF] = prev &amp; 1\n</code></pre>"},{"location":"Lemon.pie/cpu/#components.CPU.SUBN_Vx_Vy","title":"<code>SUBN_Vx_Vy()</code>","text":"<p>$8xy7 - Set Vx = Vy - Vx, set VF = NOT borrow.</p> Source code in <code>components/cpu.py</code> <pre><code>def SUBN_Vx_Vy(self) -&gt; None:\n    \"\"\"\n    $8xy7 - Set Vx = Vy - Vx, set VF = NOT borrow.\n    \"\"\"\n    self.V[self.op.x] = (self.V[self.op.y] - self.V[self.op.x]) &amp; 0xFF\n    if self.V[self.op.x] &gt; self.V[self.op.y]:\n        self.V[0xF] = 0\n    else:\n        self.V[0xF] = 1\n</code></pre>"},{"location":"Lemon.pie/cpu/#components.CPU.SHL_Vx_Vy","title":"<code>SHL_Vx_Vy()</code>","text":"<p>$8xyE - Set Vx = Vx SHL 1.</p> Source code in <code>components/cpu.py</code> <pre><code>def SHL_Vx_Vy(self) -&gt; None:\n    \"\"\"\n    $8xyE - Set Vx = Vx SHL 1.\n    \"\"\"\n    y = self.V[self.op.y]\n\n    self.V[self.op.x] = (y &lt;&lt; 1) &amp; 0xFF\n    self.V[0xF] = (y &amp; 0xFF) &gt;&gt; 7\n</code></pre>"},{"location":"Lemon.pie/cpu/#components.CPU.SNE_Vx_Vy","title":"<code>SNE_Vx_Vy()</code>","text":"<p>$9xy0 - Skip next instruction if Vx != Vy.</p> Source code in <code>components/cpu.py</code> <pre><code>def SNE_Vx_Vy(self) -&gt; None:\n    \"\"\"\n    $9xy0 - Skip next instruction if Vx != Vy.\n    \"\"\"\n    if self.V[self.op.x] != self.V[self.op.y]:\n        self.PC += 2\n</code></pre>"},{"location":"Lemon.pie/cpu/#components.CPU.LD_I_addr","title":"<code>LD_I_addr()</code>","text":"<p>$Annn - Set I = nnn.</p> Source code in <code>components/cpu.py</code> <pre><code>def LD_I_addr(self) -&gt; None:\n    \"\"\"\n    $Annn - Set I = nnn.\n    \"\"\"\n    self.I = self.op.nnn\n</code></pre>"},{"location":"Lemon.pie/cpu/#components.CPU.JP_V0_addr","title":"<code>JP_V0_addr()</code>","text":"<p>$Bnnn - Jump to location nnn + V0.</p> Source code in <code>components/cpu.py</code> <pre><code>def JP_V0_addr(self) -&gt; None:\n    \"\"\"\n    $Bnnn - Jump to location nnn + V0.\n    \"\"\"\n    self.PC = self.op.nnn + self.V[0]\n</code></pre>"},{"location":"Lemon.pie/cpu/#components.CPU.RND_Vx_byte","title":"<code>RND_Vx_byte()</code>","text":"<p>$Cxkk - Set Vx = random byte AND kk.</p> Source code in <code>components/cpu.py</code> <pre><code>def RND_Vx_byte(self) -&gt; None:\n    \"\"\"\n    $Cxkk - Set Vx = random byte AND kk.\n    \"\"\"\n    self.V[self.op.x] = randint(0, 0xFF) &amp; self.op.kk\n</code></pre>"},{"location":"Lemon.pie/cpu/#components.CPU.DRW_Vx_Vy_nibble","title":"<code>DRW_Vx_Vy_nibble()</code>","text":"<p>$Dxyn - Display n-byte sprite starting at memory location I at (Vx, Vy), set VF = collision. :)</p> Source code in <code>components/cpu.py</code> <pre><code>def DRW_Vx_Vy_nibble(self) -&gt; None:\n    \"\"\"\n    $Dxyn - Display n-byte sprite starting at memory location I at (Vx, Vy), set VF = collision. :)\n    \"\"\"\n    if not self.sync:\n        self.PC -= 2\n        return\n\n    x = self.V[self.op.x] % COLUMNS\n    y = self.V[self.op.y] % ROWS\n\n    self.V[0xF] = 0\n\n    for i in range(self.op.n):\n        sprite = self.memory.space[self.I + i]\n        if (y + i) &lt;= ROWS:\n            for j in range(8):\n                if (x + j) &lt;= COLUMNS:\n                    px = (sprite &gt;&gt; (7 - j)) &amp; 1\n                    index = self.display.wrap(x + j, y + i)\n\n                    if px == 1 and self.display.buffer[index] == 1:\n                        self.V[0xF] = 1\n\n                    self.display.buffer[index] ^= px\n\n    self.sync = False\n</code></pre>"},{"location":"Lemon.pie/cpu/#components.CPU.Jp_addr_E","title":"<code>Jp_addr_E()</code>","text":"<p>$Exkk - Jump to a machine code routine at kk.</p> Source code in <code>components/cpu.py</code> <pre><code>def Jp_addr_E(self) -&gt; None:\n    \"\"\"\n    $Exkk - Jump to a machine code routine at kk.\n    \"\"\"\n    optab = {0x9E: self.SKP_Vx, 0xA1: self.SKNP_Vx}\n    optab[self.op.kk]()\n</code></pre>"},{"location":"Lemon.pie/cpu/#components.CPU.SKP_Vx","title":"<code>SKP_Vx()</code>","text":"<p>$Ex9E - Skip next instruction if key with the value of Vx is pressed.</p> Source code in <code>components/cpu.py</code> <pre><code>def SKP_Vx(self) -&gt; None:\n    \"\"\"\n    $Ex9E - Skip next instruction if key with the value of Vx is pressed.\n    \"\"\"\n    if self.keypad.state[self.V[self.op.x] &amp; 0xF]:\n        self.PC += 2\n</code></pre>"},{"location":"Lemon.pie/cpu/#components.CPU.SKNP_Vx","title":"<code>SKNP_Vx()</code>","text":"<p>$ExA1 - Skip next instruction if key with the value of Vx is not pressed.</p> Source code in <code>components/cpu.py</code> <pre><code>def SKNP_Vx(self) -&gt; None:\n    \"\"\"\n    $ExA1 - Skip next instruction if key with the value of Vx is not pressed.\n    \"\"\"\n    if not self.keypad.state[self.V[self.op.x] &amp; 0xF]:\n        self.PC += 2\n</code></pre>"},{"location":"Lemon.pie/cpu/#components.CPU.Jp_addr_F","title":"<code>Jp_addr_F()</code>","text":"<p>$Fxkk - Jump to a machine code routine at kk.</p> Source code in <code>components/cpu.py</code> <pre><code>def Jp_addr_F(self) -&gt; None:\n    \"\"\"\n    $Fxkk - Jump to a machine code routine at kk.\n    \"\"\"\n    optab = {\n        0x07: self.LD_Vx_DT,\n        0x0A: self.LD_Vx_K,\n        0x15: self.LD_DT_Vx,\n        0x18: self.LD_ST_Vx,\n        0x1E: self.ADD_I_Vx,\n        0x29: self.LD_F_Vx,\n        0x33: self.LD_B_Vx,\n        0x55: self.LD_I_Vx,\n        0x65: self.LD_Vx_I,\n    }\n    optab[self.op.kk]()\n</code></pre>"},{"location":"Lemon.pie/cpu/#components.CPU.LD_Vx_DT","title":"<code>LD_Vx_DT()</code>","text":"<p>$Fx07 - Set Vx = delay timer value.</p> Source code in <code>components/cpu.py</code> <pre><code>def LD_Vx_DT(self) -&gt; None:\n    \"\"\"\n    $Fx07 - Set Vx = delay timer value.\n    \"\"\"\n    self.V[self.op.x] = self.DT\n</code></pre>"},{"location":"Lemon.pie/cpu/#components.CPU.LD_Vx_K","title":"<code>LD_Vx_K()</code>","text":"<p>$Fx0A - Wait for a key press, store the value of the key in Vx.</p> Source code in <code>components/cpu.py</code> <pre><code>def LD_Vx_K(self) -&gt; None:\n    \"\"\"\n    $Fx0A - Wait for a key press, store the value of the key in Vx.\n    \"\"\"\n    self.halt = True\n</code></pre>"},{"location":"Lemon.pie/cpu/#components.CPU.LD_DT_Vx","title":"<code>LD_DT_Vx()</code>","text":"<p>$Fx15 - Set delay timer = Vx.</p> Source code in <code>components/cpu.py</code> <pre><code>def LD_DT_Vx(self) -&gt; None:\n    \"\"\"\n    $Fx15 - Set delay timer = Vx.\n    \"\"\"\n    self.DT = self.V[self.op.x]\n</code></pre>"},{"location":"Lemon.pie/cpu/#components.CPU.LD_ST_Vx","title":"<code>LD_ST_Vx()</code>","text":"<p>$Fx18 - Set sound timer = Vx.</p> Source code in <code>components/cpu.py</code> <pre><code>def LD_ST_Vx(self) -&gt; None:\n    \"\"\"\n    $Fx18 - Set sound timer = Vx.\n    \"\"\"\n    self.ST = self.V[self.op.x]\n</code></pre>"},{"location":"Lemon.pie/cpu/#components.CPU.ADD_I_Vx","title":"<code>ADD_I_Vx()</code>","text":"<p>$Fx1E - Set I = I + Vx.</p> Source code in <code>components/cpu.py</code> <pre><code>def ADD_I_Vx(self) -&gt; None:\n    \"\"\"\n    $Fx1E - Set I = I + Vx.\n    \"\"\"\n    self.I += self.V[self.op.x]\n</code></pre>"},{"location":"Lemon.pie/cpu/#components.CPU.LD_F_Vx","title":"<code>LD_F_Vx()</code>","text":"<p>$Fx29 - Set I = location of sprite for digit Vx.</p> Source code in <code>components/cpu.py</code> <pre><code>def LD_F_Vx(self) -&gt; None:\n    \"\"\"\n    $Fx29 - Set I = location of sprite for digit Vx.\n    \"\"\"\n    self.I = (self.V[self.op.x] * 5) &amp; 0x0FFF\n</code></pre>"},{"location":"Lemon.pie/cpu/#components.CPU.LD_B_Vx","title":"<code>LD_B_Vx()</code>","text":"<p>$Fx33 - Store BCD representation of Vx in memory locations I, I+1, and I+2.</p> Source code in <code>components/cpu.py</code> <pre><code>def LD_B_Vx(self) -&gt; None:\n    \"\"\"\n    $Fx33 - Store BCD representation of Vx in memory locations I, I+1, and I+2.\n    \"\"\"\n    self.memory.space[self.I] = self.V[self.op.x] // 100\n    self.memory.space[self.I + 1] = (self.V[self.op.x] % 100) // 10\n    self.memory.space[self.I + 2] = self.V[self.op.x] % 10\n</code></pre>"},{"location":"Lemon.pie/cpu/#components.CPU.LD_I_Vx","title":"<code>LD_I_Vx()</code>","text":"<p>$Fx55 - Store registers V0 through Vx in memory starting at location I.</p> Source code in <code>components/cpu.py</code> <pre><code>def LD_I_Vx(self) -&gt; None:\n    \"\"\"\n    $Fx55 - Store registers V0 through Vx in memory starting at location I.\n    \"\"\"\n    for i in range(self.op.x + 1):\n        self.memory.space[self.I + i] = self.V[i]\n    self.I += self.op.x + 1\n</code></pre>"},{"location":"Lemon.pie/cpu/#components.CPU.LD_Vx_I","title":"<code>LD_Vx_I()</code>","text":"<p>$Fx65 - Read registers V0 through Vx from memory starting at location I.</p> Source code in <code>components/cpu.py</code> <pre><code>def LD_Vx_I(self) -&gt; None:\n    \"\"\"\n    $Fx65 - Read registers V0 through Vx from memory starting at location I.\n    \"\"\"\n    for i in range(self.op.x + 1):\n        self.V[i] = self.memory.space[self.I + i]\n    self.I += self.op.x + 1\n</code></pre>"},{"location":"Lemon.pie/cpu/#components.CPU.beep","title":"<code>beep()</code>","text":"<p>Make a beep sound.</p> Source code in <code>components/cpu.py</code> <pre><code>def beep(self) -&gt; None:\n    \"\"\"\n    Make a beep sound.\n    \"\"\"\n    self.sound.play()\n</code></pre>"},{"location":"Lemon.pie/cpu/#components.CPU.cycle","title":"<code>cycle()</code>","text":"<p>Fetch, Decode and Execute instructions from the memory.</p> Source code in <code>components/cpu.py</code> <pre><code>def cycle(self) -&gt; None:\n    \"\"\"\n    Fetch, Decode and Execute instructions from the memory.\n    \"\"\"\n    fetch = (self.memory.space[self.PC] &lt;&lt; 8) | self.memory.space[self.PC + 1]\n    self.op = Opcode(fetch)\n    self.PC += 2\n\n    try:\n        self.optable[(self.op.type &amp; 0xF000) &gt;&gt; 12]()\n    except KeyError:\n        logging.error(f\"{CROSS} Opcode not found: {hex(self.op.inst)}\")\n        self.display.destroy()\n</code></pre>"},{"location":"Lemon.pie/cpu/#components.CPU.handle_timers","title":"<code>handle_timers()</code>","text":"<p>Decrement ST and DT.</p> Source code in <code>components/cpu.py</code> <pre><code>def handle_timers(self) -&gt; None:\n    \"\"\"\n    Decrement ST and DT.\n    \"\"\"\n    if self.DT &gt; 0:\n        self.DT -= 1\n\n    if self.ST &gt; 0:\n        self.ST = 0\n        self.beep()\n</code></pre>"},{"location":"Lemon.pie/display/","title":"Display","text":"<p>Object for handling creation, rendering and deletion of the emulator window.</p> Source code in <code>components/display.py</code> <pre><code>class Display:\n    \"\"\"\n    Object for handling creation, rendering and deletion of the emulator\n    window.\n    \"\"\"\n\n    __slots__ = (\"buffer\", \"multiplier\", \"screen\")\n\n    def __init__(self, screen: pygame.Surface, multiplier: int):\n        \"\"\"\n        Display Constructor.\n\n        Args:\n            screen: A [pygame.Surface](https://www.pygame.org/docs/ref/surface.html#pygame.Surface) on which sprites are drawn.\n            multiplier: Constant for scaling the window.\n\n        Attributes:\n            buffer (bytearray): Display Buffer; used to store sprite location on the window.\n        \"\"\"\n        self.screen = screen\n        self.multiplier = multiplier\n        self.buffer: bytearray = bytearray(ROWS * COLUMNS)\n\n    @classmethod\n    def create(cls, multiplier: int) -&gt; t.Self:\n        \"\"\"\n        Create the window and sets caption and icon.\n\n        Args:\n            multiplier: Constant for scaling the window.\n        \"\"\"\n        screen = pygame.display.set_mode(\n            (COLUMNS * multiplier, ROWS * multiplier), vsync=True\n        )\n        pygame.display.set_caption(\"Lemon\")\n        pygame.display.set_icon(img)\n        self = cls(screen, multiplier)\n\n        return self\n\n    def refresh(self) -&gt; None:\n        \"\"\"\n        Refresh the display using\n        [pygame.display.flip](https://www.pygame.org/docs/ref/display.html?highlight=pygame%20display%20flip#pygame.display.flip)\n        \"\"\"\n        pygame.display.flip()\n\n    def destroy(self) -&gt; None:\n        \"\"\"\n        Destroy the window and exit the emulator.\n        \"\"\"\n        pygame.quit()\n        raise SystemExit\n\n    def wrap(self, x: int, y: int) -&gt; int:\n        \"\"\"\n        Wrap overflown/underflown pixels back at the opposite end.\n\n        Args:\n            x: The x position.\n            y: The y position.\n\n        Returns:\n            loc: location of the cordinates in the display buffer.\n        \"\"\"\n        x %= COLUMNS\n        y %= ROWS\n\n        loc = x + (y * COLUMNS)\n        return loc\n\n    def render(self) -&gt; None:\n        \"\"\"\n        Render the ON/OFF pixels onto the screen.\n        \"\"\"\n        self.screen.fill(COLORS[\"OFF\"])\n        for i in range(ROWS * COLUMNS):\n            x = (i % COLUMNS) * self.multiplier\n            y = (i // COLUMNS) * self.multiplier\n\n            if self.buffer[i]:\n                pygame.draw.rect(\n                    self.screen,\n                    COLORS[\"ON\"],\n                    pygame.Rect(x, y, self.multiplier, self.multiplier),\n                )\n        self.refresh()\n\n    def clear(self) -&gt; None:\n        \"\"\"\n        Clear the display buffer.\n        \"\"\"\n        self.buffer = bytearray(ROWS * COLUMNS)\n</code></pre>"},{"location":"Lemon.pie/display/#components.Display.__init__","title":"<code>__init__(screen, multiplier)</code>","text":"<p>Display Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>screen</code> <code>Surface</code> <p>A pygame.Surface on which sprites are drawn.</p> required <code>multiplier</code> <code>int</code> <p>Constant for scaling the window.</p> required <p>Attributes:</p> Name Type Description <code>buffer</code> <code>bytearray</code> <p>Display Buffer; used to store sprite location on the window.</p> Source code in <code>components/display.py</code> <pre><code>def __init__(self, screen: pygame.Surface, multiplier: int):\n    \"\"\"\n    Display Constructor.\n\n    Args:\n        screen: A [pygame.Surface](https://www.pygame.org/docs/ref/surface.html#pygame.Surface) on which sprites are drawn.\n        multiplier: Constant for scaling the window.\n\n    Attributes:\n        buffer (bytearray): Display Buffer; used to store sprite location on the window.\n    \"\"\"\n    self.screen = screen\n    self.multiplier = multiplier\n    self.buffer: bytearray = bytearray(ROWS * COLUMNS)\n</code></pre>"},{"location":"Lemon.pie/display/#components.Display.create","title":"<code>create(multiplier)</code>  <code>classmethod</code>","text":"<p>Create the window and sets caption and icon.</p> <p>Parameters:</p> Name Type Description Default <code>multiplier</code> <code>int</code> <p>Constant for scaling the window.</p> required Source code in <code>components/display.py</code> <pre><code>@classmethod\ndef create(cls, multiplier: int) -&gt; t.Self:\n    \"\"\"\n    Create the window and sets caption and icon.\n\n    Args:\n        multiplier: Constant for scaling the window.\n    \"\"\"\n    screen = pygame.display.set_mode(\n        (COLUMNS * multiplier, ROWS * multiplier), vsync=True\n    )\n    pygame.display.set_caption(\"Lemon\")\n    pygame.display.set_icon(img)\n    self = cls(screen, multiplier)\n\n    return self\n</code></pre>"},{"location":"Lemon.pie/display/#components.Display.refresh","title":"<code>refresh()</code>","text":"<p>Refresh the display using pygame.display.flip</p> Source code in <code>components/display.py</code> <pre><code>def refresh(self) -&gt; None:\n    \"\"\"\n    Refresh the display using\n    [pygame.display.flip](https://www.pygame.org/docs/ref/display.html?highlight=pygame%20display%20flip#pygame.display.flip)\n    \"\"\"\n    pygame.display.flip()\n</code></pre>"},{"location":"Lemon.pie/display/#components.Display.destroy","title":"<code>destroy()</code>","text":"<p>Destroy the window and exit the emulator.</p> Source code in <code>components/display.py</code> <pre><code>def destroy(self) -&gt; None:\n    \"\"\"\n    Destroy the window and exit the emulator.\n    \"\"\"\n    pygame.quit()\n    raise SystemExit\n</code></pre>"},{"location":"Lemon.pie/display/#components.Display.wrap","title":"<code>wrap(x, y)</code>","text":"<p>Wrap overflown/underflown pixels back at the opposite end.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>The x position.</p> required <code>y</code> <code>int</code> <p>The y position.</p> required <p>Returns:</p> Name Type Description <code>loc</code> <code>int</code> <p>location of the cordinates in the display buffer.</p> Source code in <code>components/display.py</code> <pre><code>def wrap(self, x: int, y: int) -&gt; int:\n    \"\"\"\n    Wrap overflown/underflown pixels back at the opposite end.\n\n    Args:\n        x: The x position.\n        y: The y position.\n\n    Returns:\n        loc: location of the cordinates in the display buffer.\n    \"\"\"\n    x %= COLUMNS\n    y %= ROWS\n\n    loc = x + (y * COLUMNS)\n    return loc\n</code></pre>"},{"location":"Lemon.pie/display/#components.Display.render","title":"<code>render()</code>","text":"<p>Render the ON/OFF pixels onto the screen.</p> Source code in <code>components/display.py</code> <pre><code>def render(self) -&gt; None:\n    \"\"\"\n    Render the ON/OFF pixels onto the screen.\n    \"\"\"\n    self.screen.fill(COLORS[\"OFF\"])\n    for i in range(ROWS * COLUMNS):\n        x = (i % COLUMNS) * self.multiplier\n        y = (i // COLUMNS) * self.multiplier\n\n        if self.buffer[i]:\n            pygame.draw.rect(\n                self.screen,\n                COLORS[\"ON\"],\n                pygame.Rect(x, y, self.multiplier, self.multiplier),\n            )\n    self.refresh()\n</code></pre>"},{"location":"Lemon.pie/display/#components.Display.clear","title":"<code>clear()</code>","text":"<p>Clear the display buffer.</p> Source code in <code>components/display.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"\n    Clear the display buffer.\n    \"\"\"\n    self.buffer = bytearray(ROWS * COLUMNS)\n</code></pre>"},{"location":"Lemon.pie/keypad/","title":"Keypad","text":"<p>An object represeting a 16-key keypad of a standard keypad.</p> Source code in <code>components/keypad.py</code> <pre><code>class Keypad:\n    \"\"\"\n    An object represeting a 16-key keypad of a standard keypad.\n    \"\"\"\n\n    __slots__ = (\"state\",)\n\n    def __init__(self) -&gt; None:\n        \"\"\"\n        Keypad Constructor.\n\n        Attributes:\n            state: State storing KEYUP and KEYDOWN status of the 16 keys.\n        \"\"\"\n        self.state: t.List[int] = [0] * 16\n\n    @property\n    def keymap(self) -&gt; t.Mapping[int, int]:\n        \"\"\"\n        Mapping of pygame keys with locations on the keypad.\n        \"\"\"\n        return {\n            pg.K_1: 1,\n            pg.K_2: 2,\n            pg.K_3: 3,\n            pg.K_4: 12,\n            pg.K_q: 4,\n            pg.K_w: 5,\n            pg.K_e: 6,\n            pg.K_r: 13,\n            pg.K_a: 7,\n            pg.K_s: 8,\n            pg.K_d: 9,\n            pg.K_f: 14,\n            pg.K_z: 10,\n            pg.K_x: 0,\n            pg.K_c: 11,\n            pg.K_v: 15,\n        }\n\n    def set(self, index: int) -&gt; None:\n        \"\"\"\n        Method to set a key in state array.\n\n        Args:\n            index: The key to set.\n        \"\"\"\n        self.state[index] = 1\n\n    def unset(self, index: int) -&gt; None:\n        \"\"\"\n        Method to unset a key in state array.\n\n        Args:\n            index: The key to unset.\n        \"\"\"\n        self.state[index] = 0\n\n    def handle(self, event: Event) -&gt; None:\n        \"\"\"\n        Handler for KEYDOWN.\n\n        Args:\n            event: A pygame Event.\n        \"\"\"\n        if event.key in self.keymap:\n            key = self.keymap[event.key]\n            self.set(key)\n            return key\n</code></pre>"},{"location":"Lemon.pie/keypad/#components.Keypad.keymap","title":"<code>keymap: t.Mapping[int, int]</code>  <code>property</code>","text":"<p>Mapping of pygame keys with locations on the keypad.</p>"},{"location":"Lemon.pie/keypad/#components.Keypad.__init__","title":"<code>__init__()</code>","text":"<p>Keypad Constructor.</p> <p>Attributes:</p> Name Type Description <code>state</code> <p>State storing KEYUP and KEYDOWN status of the 16 keys.</p> Source code in <code>components/keypad.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"\n    Keypad Constructor.\n\n    Attributes:\n        state: State storing KEYUP and KEYDOWN status of the 16 keys.\n    \"\"\"\n    self.state: t.List[int] = [0] * 16\n</code></pre>"},{"location":"Lemon.pie/keypad/#components.Keypad.set","title":"<code>set(index)</code>","text":"<p>Method to set a key in state array.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The key to set.</p> required Source code in <code>components/keypad.py</code> <pre><code>def set(self, index: int) -&gt; None:\n    \"\"\"\n    Method to set a key in state array.\n\n    Args:\n        index: The key to set.\n    \"\"\"\n    self.state[index] = 1\n</code></pre>"},{"location":"Lemon.pie/keypad/#components.Keypad.unset","title":"<code>unset(index)</code>","text":"<p>Method to unset a key in state array.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The key to unset.</p> required Source code in <code>components/keypad.py</code> <pre><code>def unset(self, index: int) -&gt; None:\n    \"\"\"\n    Method to unset a key in state array.\n\n    Args:\n        index: The key to unset.\n    \"\"\"\n    self.state[index] = 0\n</code></pre>"},{"location":"Lemon.pie/keypad/#components.Keypad.handle","title":"<code>handle(event)</code>","text":"<p>Handler for KEYDOWN.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Event</code> <p>A pygame Event.</p> required Source code in <code>components/keypad.py</code> <pre><code>def handle(self, event: Event) -&gt; None:\n    \"\"\"\n    Handler for KEYDOWN.\n\n    Args:\n        event: A pygame Event.\n    \"\"\"\n    if event.key in self.keymap:\n        key = self.keymap[event.key]\n        self.set(key)\n        return key\n</code></pre>"},{"location":"Lemon.pie/lemon/","title":"Lemon","text":"<p>As the main entry point for lemon emulator, this class takes care of interfacing with the user and the internal devices.</p> Source code in <code>lemon.py</code> <pre><code>class Lemon:\n    \"\"\"\n    As the main entry point for lemon emulator,\n    this class takes care of interfacing with the user and\n    the internal devices.\n    \"\"\"\n\n    __slots__ = (\"cpu\", \"display\", \"keypad\", \"memory\")\n\n    def __init__(self, rom: str, mul: int) -&gt; None:\n        \"\"\"\n        Lemon Constructor.\n        The constructor is responsible for loading font and rom, and also initializing other\n        devices.\n\n        Args:\n            rom: Path to the ROM file.\n            mul: The screen size multiplier.\n\n        Attributes:\n            memory (Memory): Primary Memory of size 4096 bytes.\n            display (Display): Display Handler for rendering sprites.\n            keypad (Keypad): 16-key hexadecimal keypad for taking input.\n            cpu (CPU): Object representing Central Processing Unit of the emulator.\n        \"\"\"\n        self.memory: Memory = Memory()\n        self.load_font()\n        self.load_rom(rom)\n        self.display: Display = Display.create(multiplier=mul)\n        self.keypad: Keypad = Keypad()\n        self.cpu: CPU = CPU(\n            display=self.display, memory=self.memory, keypad=self.keypad\n        )\n\n    def load_font(self) -&gt; None:\n        \"\"\"\n        Load Font from the `/bin/FONT` file in memory from location `0x0`\n        \"\"\"\n        self.memory.load_binary(\"./bin/FONT\")\n        logging.info(f\"{TICK} Successfully loaded Fontset at location 0x0\")\n\n    def load_rom(self, rom: str) -&gt; None:\n        \"\"\"\n        Load ROM in memory from location `0x200` (512)\n\n        Args:\n            rom: Path to the ROM file.\n        \"\"\"\n        self.memory.load_binary(rom, offset=INIT_LOC_CONSTANT)\n        logging.info(\n            f\"{TICK} Successfully loaded ROM at location {hex(INIT_LOC_CONSTANT)}\"\n        )\n\n    def tick(self) -&gt; None:\n        \"\"\"\n        Method representing a single tick from the emulator.\n        \"\"\"\n        for ic in range(10):\n            if not self.cpu.halt:\n                self.cpu.cycle()\n                self.cpu.sync = not ic\n\n            self.display.render()\n\n        self.cpu.handle_timers()\n\n    def run(self) -&gt; None:\n        \"\"\"\n        Step through the emulation indefinitely.\n        \"\"\"\n        is_running = True\n        while is_running:\n            self.tick()\n\n            for event in pygame.event.get():\n                if event.type == pygame.QUIT:\n                    is_running = False\n                if event.type == pygame.KEYDOWN:\n                    self.keypad.handle(event)\n                if event.type == pygame.KEYUP:\n                    if event.key in self.keypad.keymap:\n                        key = self.cpu.keypad.keymap[event.key]\n                        if self.cpu.halt:\n                            self.cpu.V[self.cpu.op.x] = key\n                            self.cpu.halt = False\n                        self.keypad.unset(key)\n\n        self.display.destroy()\n</code></pre>"},{"location":"Lemon.pie/lemon/#lemon.Lemon.__init__","title":"<code>__init__(rom, mul)</code>","text":"<p>Lemon Constructor. The constructor is responsible for loading font and rom, and also initializing other devices.</p> <p>Parameters:</p> Name Type Description Default <code>rom</code> <code>str</code> <p>Path to the ROM file.</p> required <code>mul</code> <code>int</code> <p>The screen size multiplier.</p> required <p>Attributes:</p> Name Type Description <code>memory</code> <code>Memory</code> <p>Primary Memory of size 4096 bytes.</p> <code>display</code> <code>Display</code> <p>Display Handler for rendering sprites.</p> <code>keypad</code> <code>Keypad</code> <p>16-key hexadecimal keypad for taking input.</p> <code>cpu</code> <code>CPU</code> <p>Object representing Central Processing Unit of the emulator.</p> Source code in <code>lemon.py</code> <pre><code>def __init__(self, rom: str, mul: int) -&gt; None:\n    \"\"\"\n    Lemon Constructor.\n    The constructor is responsible for loading font and rom, and also initializing other\n    devices.\n\n    Args:\n        rom: Path to the ROM file.\n        mul: The screen size multiplier.\n\n    Attributes:\n        memory (Memory): Primary Memory of size 4096 bytes.\n        display (Display): Display Handler for rendering sprites.\n        keypad (Keypad): 16-key hexadecimal keypad for taking input.\n        cpu (CPU): Object representing Central Processing Unit of the emulator.\n    \"\"\"\n    self.memory: Memory = Memory()\n    self.load_font()\n    self.load_rom(rom)\n    self.display: Display = Display.create(multiplier=mul)\n    self.keypad: Keypad = Keypad()\n    self.cpu: CPU = CPU(\n        display=self.display, memory=self.memory, keypad=self.keypad\n    )\n</code></pre>"},{"location":"Lemon.pie/lemon/#lemon.Lemon.load_font","title":"<code>load_font()</code>","text":"<p>Load Font from the <code>/bin/FONT</code> file in memory from location <code>0x0</code></p> Source code in <code>lemon.py</code> <pre><code>def load_font(self) -&gt; None:\n    \"\"\"\n    Load Font from the `/bin/FONT` file in memory from location `0x0`\n    \"\"\"\n    self.memory.load_binary(\"./bin/FONT\")\n    logging.info(f\"{TICK} Successfully loaded Fontset at location 0x0\")\n</code></pre>"},{"location":"Lemon.pie/lemon/#lemon.Lemon.load_rom","title":"<code>load_rom(rom)</code>","text":"<p>Load ROM in memory from location <code>0x200</code> (512)</p> <p>Parameters:</p> Name Type Description Default <code>rom</code> <code>str</code> <p>Path to the ROM file.</p> required Source code in <code>lemon.py</code> <pre><code>def load_rom(self, rom: str) -&gt; None:\n    \"\"\"\n    Load ROM in memory from location `0x200` (512)\n\n    Args:\n        rom: Path to the ROM file.\n    \"\"\"\n    self.memory.load_binary(rom, offset=INIT_LOC_CONSTANT)\n    logging.info(\n        f\"{TICK} Successfully loaded ROM at location {hex(INIT_LOC_CONSTANT)}\"\n    )\n</code></pre>"},{"location":"Lemon.pie/lemon/#lemon.Lemon.tick","title":"<code>tick()</code>","text":"<p>Method representing a single tick from the emulator.</p> Source code in <code>lemon.py</code> <pre><code>def tick(self) -&gt; None:\n    \"\"\"\n    Method representing a single tick from the emulator.\n    \"\"\"\n    for ic in range(10):\n        if not self.cpu.halt:\n            self.cpu.cycle()\n            self.cpu.sync = not ic\n\n        self.display.render()\n\n    self.cpu.handle_timers()\n</code></pre>"},{"location":"Lemon.pie/lemon/#lemon.Lemon.run","title":"<code>run()</code>","text":"<p>Step through the emulation indefinitely.</p> Source code in <code>lemon.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"\n    Step through the emulation indefinitely.\n    \"\"\"\n    is_running = True\n    while is_running:\n        self.tick()\n\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                is_running = False\n            if event.type == pygame.KEYDOWN:\n                self.keypad.handle(event)\n            if event.type == pygame.KEYUP:\n                if event.key in self.keypad.keymap:\n                    key = self.cpu.keypad.keymap[event.key]\n                    if self.cpu.halt:\n                        self.cpu.V[self.cpu.op.x] = key\n                        self.cpu.halt = False\n                    self.keypad.unset(key)\n\n    self.display.destroy()\n</code></pre>"},{"location":"Lemon.pie/memory/","title":"Memory","text":"<p>Primary Memory of the CPU.</p> Source code in <code>components/memory.py</code> <pre><code>class Memory:\n    \"\"\"\n    Primary Memory of the CPU.\n    \"\"\"\n\n    __slots__ = (\"space\",)\n\n    def __init__(self) -&gt; None:\n        \"\"\"\n        Memory Constructor.\n\n        Attributes:\n            space (bytearray): A bytearray of size 4096 virtually representing CHP-8 memory.\n        \"\"\"\n        self.space: bytearray = bytearray(4096)\n\n    def load_binary(self, binary: str, offset: int = 0) -&gt; None:\n        \"\"\"\n        Load file onto the RAM.\n\n        Arguments:\n            binary: Path to the binary.\n            offset: From where to start loading the elements of the binary.\n        \"\"\"\n        with open(binary, \"rb\") as f:\n            for i, data in enumerate(f.read()):\n                self.space[i + offset] = data\n</code></pre>"},{"location":"Lemon.pie/memory/#components.Memory.__init__","title":"<code>__init__()</code>","text":"<p>Memory Constructor.</p> <p>Attributes:</p> Name Type Description <code>space</code> <code>bytearray</code> <p>A bytearray of size 4096 virtually representing CHP-8 memory.</p> Source code in <code>components/memory.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"\n    Memory Constructor.\n\n    Attributes:\n        space (bytearray): A bytearray of size 4096 virtually representing CHP-8 memory.\n    \"\"\"\n    self.space: bytearray = bytearray(4096)\n</code></pre>"},{"location":"Lemon.pie/memory/#components.Memory.load_binary","title":"<code>load_binary(binary, offset=0)</code>","text":"<p>Load file onto the RAM.</p> <p>Parameters:</p> Name Type Description Default <code>binary</code> <code>str</code> <p>Path to the binary.</p> required <code>offset</code> <code>int</code> <p>From where to start loading the elements of the binary.</p> <code>0</code> Source code in <code>components/memory.py</code> <pre><code>def load_binary(self, binary: str, offset: int = 0) -&gt; None:\n    \"\"\"\n    Load file onto the RAM.\n\n    Arguments:\n        binary: Path to the binary.\n        offset: From where to start loading the elements of the binary.\n    \"\"\"\n    with open(binary, \"rb\") as f:\n        for i, data in enumerate(f.read()):\n            self.space[i + offset] = data\n</code></pre>"},{"location":"Lemon.pie/opcode/","title":"Opcode","text":"<p>Operation code consisting of the information of the operation.</p> Source code in <code>components/opcode.py</code> <pre><code>class Opcode:\n    \"\"\"\n    Operation code consisting of the information of the operation.\n    \"\"\"\n\n    __slots__ = (\"inst\",)\n\n    def __new__(cls, inst: int) -&gt; t.Self:\n        if isinstance(inst, int) and len(str(inst)) &lt; 6:\n            self = super(Opcode, cls).__new__(cls)\n            return self\n\n        else:\n            raise ValueError(f\"BAD OPCODE: {inst}\")\n\n    def __init__(self, inst: int) -&gt; None:\n        \"\"\"\n        Opcode Constructor.\n\n        args:\n            inst: instruction in the format of `hex(type|x|y|n|nn|nnn)`\n        \"\"\"\n        self.inst = inst\n\n    @property\n    def type(self) -&gt; int:\n        \"\"\"\n        The type of operation. (first nibble)\n        \"\"\"\n        value = self.inst &amp; 0xF000\n        return value\n\n    @property\n    def x(self) -&gt; int:\n        \"\"\"\n        General Purpose Register lookup. (second nibble)\n        \"\"\"\n        value = (self.inst &amp; 0x0F00) &gt;&gt; 8\n        return value\n\n    @property\n    def y(self) -&gt; int:\n        \"\"\"\n        general purpose register lookup. (third nibble)\n        \"\"\"\n        value = (self.inst &amp; 0x00F0) &gt;&gt; 4\n        return value\n\n    @property\n    def n(self) -&gt; int:\n        \"\"\"\n        4-bit numeric value. (fourth nibble)\n        \"\"\"\n        value = self.inst &amp; 0x000F\n        return value\n\n    @property\n    def kk(self) -&gt; int:\n        \"\"\"\n        8-bit immediate. (third and fourth nibble)\n        \"\"\"\n        value = self.inst &amp; 0x00FF\n        return value\n\n    @property\n    def nnn(self) -&gt; int:\n        \"\"\"\n        12-bit immediate memory address. (second, third and fourth nibble)\n        \"\"\"\n        value = self.inst &amp; 0x0FFF\n        return value\n\n    def __repr__(self) -&gt; str:\n        return f\"Opcode(inst={hex(self.inst)})\"\n</code></pre>"},{"location":"Lemon.pie/opcode/#components.Opcode.type","title":"<code>type: int</code>  <code>property</code>","text":"<p>The type of operation. (first nibble)</p>"},{"location":"Lemon.pie/opcode/#components.Opcode.x","title":"<code>x: int</code>  <code>property</code>","text":"<p>General Purpose Register lookup. (second nibble)</p>"},{"location":"Lemon.pie/opcode/#components.Opcode.y","title":"<code>y: int</code>  <code>property</code>","text":"<p>general purpose register lookup. (third nibble)</p>"},{"location":"Lemon.pie/opcode/#components.Opcode.n","title":"<code>n: int</code>  <code>property</code>","text":"<p>4-bit numeric value. (fourth nibble)</p>"},{"location":"Lemon.pie/opcode/#components.Opcode.kk","title":"<code>kk: int</code>  <code>property</code>","text":"<p>8-bit immediate. (third and fourth nibble)</p>"},{"location":"Lemon.pie/opcode/#components.Opcode.nnn","title":"<code>nnn: int</code>  <code>property</code>","text":"<p>12-bit immediate memory address. (second, third and fourth nibble)</p>"},{"location":"Lemon.pie/opcode/#components.Opcode.__init__","title":"<code>__init__(inst)</code>","text":"<p>Opcode Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>inst</code> <code>int</code> <p>instruction in the format of <code>hex(type|x|y|n|nn|nnn)</code></p> required Source code in <code>components/opcode.py</code> <pre><code>def __init__(self, inst: int) -&gt; None:\n    \"\"\"\n    Opcode Constructor.\n\n    args:\n        inst: instruction in the format of `hex(type|x|y|n|nn|nnn)`\n    \"\"\"\n    self.inst = inst\n</code></pre>"}]}